# Uploading packages

library(DESeq2)
library(dplyr)
library(ggplot2)
library(tidyverse)
library(tibble)
library(readr)
library(patchwork)
library(ragg)
library(htmlwidgets)
library(matrixStats)
library(org.Hs.eg.db)
library(AnnotationDbi)
library(tidytext)
library(ashr)
library(ggrepel)
library(scales)
library(stringr)
library(gprofiler2)
library(gridExtra)
library(gtable)

# Setting directions

setwd("C:/Users/sergd/Desktop/RNA-project")
getwd()

# Loading data
data <- read_tsv("GSE162698_raw_counts_GRCh38.p13_NCBI.tsv") %>%
  mutate(GeneID = as.character(GeneID)) %>%
  column_to_rownames("GeneID")

# Loading metadata
metadata <- read.csv("Metadata.csv") %>%
  column_to_rownames("Sample")

# Matching data and metadata
stopifnot(all(rownames(metadata) == colnames(data)))

# Creating DESeq2 object
metadata$Donor <- factor(metadata$Donor)
metadata$Polarization <- factor(metadata$Polarization)

dds <- DESeqDataSetFromMatrix(
  countData = data,
  colData = metadata,
  design = ~ Polarization 
)

# Log Transformation of counts
vsd <- vst(dds, blind = TRUE)

# PCA plots

ntop <- 500
rv <- matrixStats::rowVars(assay(vsd))
top_idx <- order(rv, decreasing = TRUE)[seq_len(min(ntop, length(rv)))]

pca <- prcomp(t(assay(vsd)[top_idx, ]), center = TRUE, scale. = FALSE)
pca_loadings <- pca$rotation

pca_data <- data.frame(
  Sample = rownames(pca$x),
  PC1 = pca$x[, 1],
  PC2 = pca$x[, 2],
  PC3 = pca$x[, 3],
  PC4 = pca$x[, 4]
)

pca_data <- cbind(pca_data, metadata[rownames(pca$x), , drop = FALSE])

pc_variance <- (pca$sdev^2) / sum(pca$sdev^2) * 100

## PC1 vs PC2

### Creating the main plot

pol_cols <- c("M0"="red",
              "M1"="blue",
              "M2 (IL10)"="purple",
              "M2 (IL4)"="darkgreen",
              "TAM-like"= "gold")


don_shapes <- c(21, 22, 24)


p <- ggplot(pca_data, aes(x = PC1, y = PC2)) +
  geom_point(aes(shape = Donor, fill = Polarization),
             stroke = 0.5, size = 5.5, color = "black",
             alpha = 0.7) +
  scale_fill_manual(values = pol_cols) +
  scale_color_manual(values = pol_cols) +
  scale_shape_manual(values = don_shapes) +
  scale_y_continuous(limits = c(-50, 125), breaks = seq(-50, 125, by = 25)) +
  scale_x_continuous(limits = c(-50, 125), breaks = seq(-50, 125, by = 25)) +
  labs(
    x = paste0("PC1: ", formatC(pc_variance[1], format = "f", digits = 1), "%"),
    y = paste0("PC2: ", formatC(pc_variance[2], format = "f", digits = 1), "%")
  ) +
  theme_classic() +
  theme(
    axis.text = element_text(size = 22, color = "black"),
    axis.title.y = element_text(size = 22, face = "bold"),
    axis.title.x.bottom = element_text(size = 22, face = "bold",
                                margin = margin(t = 15, unit = "pt")),
    legend.position = "none"
  ) +
  coord_fixed(ratio = 1)


### Creating the legend

pca_data$Polarization <- factor(pca_data$Polarization, levels = names(pol_cols))
pca_data$Donor <- factor(pca_data$Donor)  

donor_levels <- levels(pca_data$Donor)
donor_nums <- setNames(as.character(seq_along(donor_levels)), donor_levels)

legend_df <- expand.grid(
  Donor = donor_levels,
  Polarization = levels(pca_data$Polarization),
  KEEP.OUT.ATTRS = FALSE
)


legend_panel <- ggplot(legend_df, aes(x = Donor, y = Polarization, shape = Donor, fill = Polarization)) +
  geom_point(size = 6, stroke = 0.5, color = "black", alpha = 0.7) + 
  scale_fill_manual(values = pol_cols) + 
  scale_shape_manual(values = don_shapes) + 
  scale_x_discrete(position = "top", labels = donor_nums) +
  scale_y_discrete(position = "left", labels = donor_nums) +
  labs(x = "Donor", y = NULL) + 
  theme_minimal() + 
  theme(panel.grid = element_blank(), 
  axis.text.x.top = element_text(size = 21, color = "black",
                             margin = margin(b = -2, unit = "pt")), 
  axis.text.y = element_text(size = 15, color = "black"),
  axis.title.x.top = element_text(size = 18, color = "black", face = "bold",
                              margin = margin(b = 8, unit = "pt")),
  axis.title.y = element_text(size = 12, color = "black", face = "bold"),
  plot.margin = margin(0, 0, 0, 0), legend.position = "none")

### Final plot

PC1_vs_PC2 <- (p | legend_panel + plot_layout(heights = c(1, 2))) +
  plot_layout(widths = c(6, 1))
PC1_vs_PC2

ggsave("PC1_vs_PC2.png", plot = PC1_vs_PC2,
       width = 8, height = 7, units = "in", dpi = 600, device = ragg::agg_png)

## PC3 vs PC4


p <- ggplot(pca_data, aes(x = PC3, y = PC4)) +
  geom_point(aes(shape = Donor, fill = Polarization),
             stroke = 0.5, size = 5.5, color = "black",
             alpha = 0.7) +
  scale_fill_manual(values = pol_cols) +
  scale_color_manual(values = pol_cols) +
  scale_shape_manual(values = don_shapes) +
  scale_y_continuous(limits = c(-30, 50), breaks = seq(-30, 50, by = 20)) +
  scale_x_continuous(limits = c(-30, 50), breaks = seq(-30, 50, by = 20)) +
  labs(
    x = paste0("PC3: ", formatC(pc_variance[3], format = "f", digits = 1), "%"),
    y = paste0("PC4: ", formatC(pc_variance[4], format = "f", digits = 1), "%")
  ) +
  theme_classic() +
  theme(
    axis.text = element_text(size = 22, color = "black"),
    axis.title.y = element_text(size = 22, face = "bold"),
    axis.title.x.bottom = element_text(size = 22, face = "bold",
                                       margin = margin(t = 15, unit = "pt")),
    legend.position = "none"
  ) +
  coord_fixed(ratio = 1)


### Creating the legend

pca_data$Polarization <- factor(pca_data$Polarization, levels = names(pol_cols))
pca_data$Donor <- factor(pca_data$Donor)  

donor_levels <- levels(pca_data$Donor)
donor_nums <- setNames(as.character(seq_along(donor_levels)), donor_levels)

legend_df <- expand.grid(
  Donor = donor_levels,
  Polarization = levels(pca_data$Polarization),
  KEEP.OUT.ATTRS = FALSE
)


legend_panel <- ggplot(legend_df, aes(x = Donor, y = Polarization, shape = Donor, fill = Polarization)) +
  geom_point(size = 6, stroke = 0.5, color = "black", alpha = 0.7) + 
  scale_fill_manual(values = pol_cols) + 
  scale_shape_manual(values = don_shapes) + 
  scale_x_discrete(position = "top", labels = donor_nums) +
  scale_y_discrete(position = "left", labels = donor_nums) +
  labs(x = "Donor", y = NULL) + 
  theme_minimal() + 
  theme(panel.grid = element_blank(), 
        axis.text.x.top = element_text(size = 21, color = "black",
                                       margin = margin(b = -2, unit = "pt")), 
        axis.text.y = element_text(size = 15, color = "black"),
        axis.title.x.top = element_text(size = 18, color = "black", face = "bold",
                                        margin = margin(b = 8, unit = "pt")),
        axis.title.y = element_text(size = 12, color = "black", face = "bold"),
        plot.margin = margin(0, 0, 0, 0), legend.position = "none")

### Final plot

PC3_vs_PC4 <- (p | legend_panel + plot_layout(heights = c(1, 2))) +
  plot_layout(widths = c(6, 1))
PC3_vs_PC4

ggsave("PC3_vs_PC4.png", plot = PC3_vs_PC4,
       width = 8, height = 7, units = "in", dpi = 600, device = ragg::agg_png)

# Extracting PC loadings:

## Loadings matrix (genes x PCs) 

gene_ids_raw <- rownames(pca_loadings)

##  Detect ID type in rownames 
is_ensembl <- all(grepl("^ENSG\\d+", gene_ids_raw))
is_numeric <- all(grepl("^\\d+$", gene_ids_raw))

keytype <- if (is_ensembl) "ENSEMBL" else if (is_numeric) "ENTREZID" else "SYMBOL"

## Strip Ensembl version suffix 
gene_key <- if (keytype == "ENSEMBL") sub("\\..*$", "", gene_ids_raw) else gene_ids_raw

## Annotation table 

key_col <- keytype

anno_raw <- AnnotationDbi::select(
  org.Hs.eg.db,
  keys    = unique(gene_key),
  keytype = keytype,
  columns = unique(c(key_col, "ENTREZID", "ENSEMBL", "SYMBOL", "GENENAME"))
) %>%
  distinct()

# Collapse 1-to-many mappings so join won't duplicate rows
anno <- anno_raw %>%
  group_by(.data[[key_col]]) %>%
  summarise(
    ENTREZID = paste(unique(na.omit(ENTREZID)), collapse = ";"),
    ENSEMBL  = paste(unique(na.omit(ENSEMBL)),  collapse = ";"),
    SYMBOL   = paste(unique(na.omit(SYMBOL)),   collapse = ";"),
    GENENAME = paste(unique(na.omit(GENENAME)), collapse = ";"),
    .groups = "drop"
  ) %>%
  rename(gene_key = !!key_col)

## Build wide table for 4 PCs
pcs <- intersect(c("PC1","PC2","PC3","PC4"), colnames(pca_loadings))
stopifnot(length(pcs) > 0)

load_wide <- as.data.frame(pca_loadings[, pcs, drop = FALSE]) %>%
  mutate(
    gene_id  = gene_ids_raw,
    gene_key = gene_key
  ) %>%
  left_join(anno, by = "gene_key") %>%
  mutate(
    SYMBOL_clean = dplyr::if_else(!is.na(SYMBOL) & SYMBOL != "", SYMBOL, gene_id)
  ) %>%
  rowwise() %>%
  ungroup() %>%
  dplyr::select(gene_id, ENSEMBL, SYMBOL, GENENAME, SYMBOL_clean, starts_with("PC"))

## Saving loadings table

readr::write_csv(load_wide, "PC_loadings.csv")

## TOP PC loadings bar plot

pcs <- intersect(c("PC1","PC2","PC3","PC4"), names(load_wide))
stopifnot(length(pcs) > 0)

plot_df <- load_wide %>%
  dplyr::select(SYMBOL_clean, all_of(pcs)) %>%
  pivot_longer(all_of(pcs), names_to = "PC", values_to = "loading") %>%
  mutate(abs_loading = abs(loading)) %>%
  group_by(PC) %>%
  slice_max(abs_loading, n = 10, with_ties = FALSE) %>%
  ungroup() %>%
  mutate(SYMBOL = reorder_within(SYMBOL_clean, abs_loading, PC))   # <-- ascending within PC

loadings_plot <- ggplot(plot_df, aes(SYMBOL, abs_loading)) +
  geom_col(fill = "#4E79A7", color = "black", linewidth = 0.35, width = 0.75) +
  coord_flip() +
  facet_wrap(~PC, scales = "free_y", axes = "all_x", axis.labels = "all_x") +
  scale_x_reordered() +
  labs(
    title = "Top 10 genes by absolute loading per PC",
    subtitle = "Ranked within each PC",
    x = "Genes",
    y = "Absolute Loading"
  ) +
  theme_classic(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5, color = "black", size = 35),
    plot.subtitle = element_text(hjust = 0.5, color = "black", size = 29),
    strip.background = element_blank(),
    strip.text = element_text(face = "bold", color = "black", size = 27),
    axis.title.x.bottom = element_text(face = "bold", color = "black", size = 28,
                                       margin = margin(t = 8, unit = "pt")),
    axis.title.y = element_text(face = "bold", color = "black", size = 35),
    axis.text.x = element_text(color = "black", size = 18),
    axis.text.y = element_text(color = "black", face = "italic", size = 18),
    axis.line = element_line(linewidth = 0.6),
    axis.ticks = element_line(linewidth = 0.4),
    panel.spacing = unit(0.9, "lines")
  )


ggsave("PC_loadings.png", plot = loadings_plot,
       width = 12, height = 10, units = "in", dpi = 600, device = ragg::agg_png)

# Normalized counts table

dds_sf <- estimateSizeFactors(dds)
sizeFactors(dds_sf) 
study_normalized_counts <- counts(dds_sf, normalized = TRUE)

# Gene IDs from normalized count matrix
gene_ids_raw <- rownames(study_normalized_counts)

# Detect ID type
is_ensembl <- all(grepl("^ENSG\\d+", gene_ids_raw))
is_numeric <- all(grepl("^\\d+$", gene_ids_raw))
keytype <- if (is_ensembl) "ENSEMBL" else if (is_numeric) "ENTREZID" else "SYMBOL"

# Strip Ensembl version if needed
gene_key <- if (keytype == "ENSEMBL") sub("\\..*$", "", gene_ids_raw) else gene_ids_raw
key_col <- keytype

# Pull annotations
anno_raw <- AnnotationDbi::select(
  org.Hs.eg.db,
  keys    = unique(gene_key),
  keytype = keytype,
  columns = unique(c(key_col, "ENTREZID", "ENSEMBL", "SYMBOL", "GENENAME"))
) %>%
  distinct()

# Collapse to 1 row per gene_key to prevent join duplication
anno <- anno_raw %>%
  group_by(.data[[key_col]]) %>%
  summarise(
    ENTREZID = paste(unique(na.omit(ENTREZID)), collapse = ";"),
    ENSEMBL  = paste(unique(na.omit(ENSEMBL)),  collapse = ";"),
    SYMBOL   = paste(unique(na.omit(SYMBOL)),   collapse = ";"),
    GENENAME = paste(unique(na.omit(GENENAME)), collapse = ";"),
    .groups = "drop"
  ) %>%
  rename(gene_key = !!key_col)

# Build final normalized-counts table
norm_counts_tbl <- as.data.frame(study_normalized_counts) %>%
  rownames_to_column("gene_id") %>%
  mutate(gene_key = gene_key) %>%
  left_join(anno, by = "gene_key") %>%
  mutate(
    SYMBOL_clean = if_else(!is.na(SYMBOL) & SYMBOL != "", SYMBOL, gene_id)
  ) %>%
  dplyr::select(gene_id, ENSEMBL, SYMBOL, GENENAME, SYMBOL_clean, starts_with("GSM"))


nrow(study_normalized_counts) == nrow(norm_counts_tbl)

readr::write_csv(norm_counts_tbl, "normalized_counts_annotated.csv")

# Differential Expression Analysis

#DESeq2 

dds_results <- DESeq(dds)

#Disperison model

plotDispEsts(dds_results)

# Extracting the results

DESeq_results <- results(dds_results, contrast = c("Polarization", "M1", "M0"), alpha = 0.01, lfcThreshold = 1)

#MA plot and Log Shrinkage

plotMA(DESeq_results, ylim = c(-15,15))
DESeq_results <- lfcShrink(dds_results, contrast = c("Polarization", "M1", "M0"), res=DESeq_results, type = 'ashr')
plotMA(DESeq_results, ylim = c(-15,15))


## Annotation

## Start from DESeq_results
res_tbl <- as.data.frame(DESeq_results) %>%
  rownames_to_column("gene_id")

## Detect ID type from result rownames
gene_ids_raw <- res_tbl$gene_id
is_ensembl <- all(grepl("^ENSG\\d+", gene_ids_raw))
is_numeric <- all(grepl("^\\d+$", gene_ids_raw))
keytype <- if (is_ensembl) "ENSEMBL" else if (is_numeric) "ENTREZID" else "SYMBOL"

## Build gene_key (strip Ensembl version if present)
gene_key <- if (keytype == "ENSEMBL") sub("\\..*$", "", gene_ids_raw) else gene_ids_raw
key_col <- keytype

## Annotation lookup
anno_raw <- AnnotationDbi::select(
  org.Hs.eg.db,
  keys    = unique(gene_key),
  keytype = keytype,
  columns = unique(c(key_col, "ENTREZID", "ENSEMBL", "SYMBOL", "GENENAME"))
) %>% distinct()

anno <- anno_raw %>%
  group_by(.data[[key_col]]) %>%
  summarise(
    ENTREZID = paste(unique(na.omit(ENTREZID)), collapse = ";"),
    ENSEMBL  = paste(unique(na.omit(ENSEMBL)),  collapse = ";"),
    SYMBOL   = paste(unique(na.omit(SYMBOL)),   collapse = ";"),
    GENENAME = paste(unique(na.omit(GENENAME)), collapse = ";"),
    .groups = "drop"
  ) %>%
  rename(gene_key = !!key_col)

## Join annotations onto DESeq results
deseq_tbl <- res_tbl %>%
  mutate(gene_key = gene_key) %>%
  left_join(anno, by = "gene_key") %>%
  mutate(SYMBOL_clean = if_else(!is.na(SYMBOL) & SYMBOL != "", SYMBOL, gene_id)) %>%
  dplyr::select(
    gene_id, ENSEMBL, SYMBOL, GENENAME, SYMBOL_clean,
    baseMean, log2FoldChange, lfcSE, pvalue, padj
  )

nrow(deseq_tbl) == nrow(res_tbl)

readr::write_csv(deseq_tbl, "DESeq2_results_annotated.csv")

# Volcano plot

deseq_volcano <- as.data.frame(deseq_tbl)
deseq_volcano$log2FoldChange <- as.numeric(deseq_tbl$log2FoldChange)
deseq_volcano$padj <- as.numeric(deseq_volcano$padj)

## 2) Differential expression labels (M1 vs M0)
deseq_volcano$diffexpressed <- "No significant change"
deseq_volcano$diffexpressed[deseq_volcano$log2FoldChange >=  1 & deseq_volcano$padj <= 0.01] <- "Upregulated in M1"
deseq_volcano$diffexpressed[deseq_volcano$log2FoldChange <= -1 & deseq_volcano$padj <= 0.01] <- "Downregulated in M1"

deseq_volcano$diffexpressed <- factor(
  deseq_volcano$diffexpressed,
  levels = c("Upregulated in M1", "No significant change", "Downregulated in M1")
)

## 3) Pick TOP 10 UP and TOP 10 DOWN (among significant ones)
top_up <- deseq_volcano %>%
  filter(!is.na(padj), padj <= 0.01, log2FoldChange >= 1) %>%
  arrange(desc(log2FoldChange)) %>%
  slice_head(n = 10)

top_down <- deseq_volcano %>%
  filter(!is.na(padj), padj <= 0.01, log2FoldChange <= -1) %>%
  arrange(log2FoldChange) %>%
  slice_head(n = 10)

top_labels <- c(top_up$SYMBOL_clean, top_down$SYMBOL_clean)

deseq_volcano$delabel <- ifelse(deseq_volcano$SYMBOL_clean %in% top_labels, deseq_volcano$SYMBOL_clean, NA)

## (optional but helps avoid weird -log10 issues)
deseq_volcano <- deseq_volcano %>% filter(!is.na(padj))

## 4) Volcano plot (same look, just new labels + new category text)
label_df <- subset(deseq_volcano, !is.na(delabel))

volcano_plot <- ggplot(deseq_volcano, aes(x = log2FoldChange, y = -log10(padj), label = delabel)) +
  geom_point(size = 2.5, shape = 21, color = "black", fill = NA) +
  geom_point(data = subset(deseq_volcano, diffexpressed == "Upregulated in M1"),
             size = 2.5, shape = 21, color = "black", fill = "#FF3333") +
  geom_point(data = subset(deseq_volcano, diffexpressed == "Downregulated in M1"),
             size = 2.5, shape = 21, color = "black", fill = "#3399FF") +
  geom_point(data = subset(deseq_volcano, diffexpressed == "No significant change"),
             size = 2.5, shape = 21, color = "black", fill = "grey50") +
  theme_classic() +
  geom_vline(xintercept = c(-1, 1), linetype = "dotted", color = "black", linewidth = 1) +
  geom_hline(yintercept = 2, linetype = "dotted", color = "black", linewidth = 1) +
  ggrepel::geom_label_repel(
    data = label_df,
    aes(
      label = delabel,
      fill  = ifelse(log2FoldChange > 0, "up", "down")
    ),
    color = "black",
    box.padding = 0.7,
    point.padding = 0,
    segment.color = "black",
    segment.size = 0.4,
    max.overlaps = Inf,
    max.iter = 5000,
    size = 6,
    fontface = "bold.italic",
    direction = "y",
    nudge_x = ifelse(label_df$log2FoldChange > 0,
                     18.5 - label_df$log2FoldChange,
                     -18.5 - label_df$log2FoldChange),
    ylim = c(2, 100),
    segment.curvature = 0,
    segment.angle = 90,
    segment.ncp = 1,
    segment.inflect = FALSE
  ) +
  scale_fill_manual(
    values = c(
      "up"   = scales::alpha("lightpink", 0.7),
      "down" = scales::alpha("lightblue", 0.7)
    ),
    guide = "none"
  ) +
  scale_x_continuous(limits = c(-19, 19), breaks = seq(-15, 15, by = 3)) +
  scale_y_continuous(limits = c(0, 63), breaks = seq(0, 60, by = 10)) +
  labs(
    x = expression("Log"[2]*"FC"),
    y = expression("-log"[10]*"(P"[adj]*")"),
    title = "Differential expression in M1 with respect to M0") +
  theme(
    axis.title = element_text(size = 24, face = "bold", color ="black"),
    axis.text = element_text(size = 28, color = "black"),
    legend.position = "none",
    plot.title = element_text(face = "bold", hjust = 0.5, color = "black", size = 32, 
                              margin = margin(b = 40, unit = "pt"))
  )

ggsave("volcano_plot.png", plot = volcano_plot,
       width = 12, height = 10, units = "in", dpi = 600, device = ragg::agg_png)


# Enrichment Analyses

## Gene Ontology Analysis

sig_genes <- deseq_tbl %>%
  filter(!is.na(padj), padj <= 0.01, abs(log2FoldChange) >= 1) %>%
  transmute(symbol = SYMBOL_clean) %>%
  separate_rows(symbol, sep = ";") %>%
  mutate(symbol = str_trim(symbol)) %>%
  filter(!is.na(symbol), symbol != "") %>%
  distinct() %>%
  pull(symbol)

length(sig_genes)
head(sig_genes, 20)

bg_genes <- deseq_tbl %>%
  filter(!is.na(padj)) %>%
  transmute(symbol = SYMBOL_clean) %>%
  separate_rows(symbol, sep = ";") %>%
  mutate(symbol = str_trim(symbol)) %>%
  filter(!is.na(symbol), symbol != "") %>%
  distinct() %>%
  pull(symbol)

gp_GO <- gost(
  query = sig_genes,
  organism = "hsapiens",
  correction_method = "g_SCS",
  user_threshold = 0.001,
  sources = c("GO:BP","GO:MF","GO:CC"),
  custom_bg = bg_genes,
  evcodes = TRUE,
)

head(gp_GO$result)
readr::write_csv(gp_GO$result, "gprofiler_GO.csv")

gostplot(gp_GO, capped = FALSE, interactive = TRUE) # Interactive plot


GO <- gostplot(gp_GO, capped = FALSE, interactive = FALSE)

top_table <- gp_GO$result %>%
  arrange(p_value) %>%
  slice_head(n = 10) %>%
  mutate(Rank = row_number()) %>%
  dplyr::select(Rank, source, term_id, term_name, p_value) %>%
  transmute(
    Rank,
    Source = source,
    `Term ID` = term_id,
    `Term name` = str_trunc(term_name, 70),
    `Adj. p` = formatC(p_value, format = "e", digits = 2)
  )

top_terms <- top_table$`Term ID`

# first point layer index
pt_idx <- which(vapply(GO$layers, function(l) inherits(l$geom, "GeomPoint"), logical(1)))[1]

# mapping for that layer
m <- GO$layers[[pt_idx]]$mapping

# keep original colors as fill (if color was mapped)
if (is.null(m$fill)) {
  if (!is.null(m$colour)) m$fill <- m$colour
  if (!is.null(m$color))  m$fill <- m$color
}

# remove colour mapping -> black outline
m$colour <- NULL
m$color  <- NULL

# remove size mapping -> constant size
m$size <- NULL

GO$layers[[pt_idx]]$mapping <- m

# outlined points with constant size
GO$layers[[pt_idx]]$aes_params$shape  <- 21
GO$layers[[pt_idx]]$aes_params$colour <- "black"
GO$layers[[pt_idx]]$aes_params$stroke <- 0.5
GO$layers[[pt_idx]]$aes_params$size   <- 5.5   # <- pick your constant point size

# palette for GO sources
my_pal <- c("GO:BP"= "#ff9900", "GO:MF" = "#dc3912", "GO:CC" = "#109618")
GO <- GO + scale_fill_manual(values = my_pal) + guides(size = "none")
# Base alpha for everything
base_alpha <- 0.5

# Add a rank column to GO$data for top 10
GO$data <- GO$data %>%
  left_join(
    gp_GO$result %>%
      arrange(p_value) %>%
      slice_head(n = 10) %>%
      mutate(Rank = row_number()) %>%
      dplyr::select(term_id, Rank),
    by = "term_id"
  ) %>%
  mutate(alpha_pt = ifelse(!is.na(Rank), 1, base_alpha))

# Map alpha per point (and turn off alpha legend)
GO <- GO +
  aes(alpha = alpha_pt) +
  scale_alpha_identity(guide = "none")

# Add rank labels for the top 10
label_df <- GO$data %>% filter(!is.na(Rank))

# remove the fixed alpha so mapping can work
GO$layers[[pt_idx]]$aes_params$alpha <- NULL

# map alpha to alpha_pt on the point layer
GO$layers[[pt_idx]]$mapping$alpha <- rlang::sym("alpha_pt")

# use the alpha values as-is (no legend)
GO <- GO + scale_alpha_identity(guide = "none")

label_df <- GO$data %>% dplyr::filter(!is.na(Rank))

p_pub <- GO +
  ggrepel::geom_label_repel(
    data = label_df,
    aes(x = order, y = logpval, label = Rank),
    inherit.aes = FALSE,
    size = 7.5,
    fontface = "bold",
    color = "black",
    fill = "grey95",               # background fill
    label.size = 0.6,              # border thickness
    label.r = unit(5, "pt"),       # corner roundness
    box.padding = 1.1,
    point.padding = 0.82,
    segment.color = "black",
    segment.size = 0.8,
    min.segment.length = 0,
    max.overlaps = Inf,
    seed = 3
  ) +
  labs(title = "GO enrichment", y = expression(-log[10](p[adj]))) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.08))) +
  theme_classic(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 33, color = "black", hjust = 0, margin = margin(b = 6)),
    axis.title.y = element_text(face = "bold", size = 22, color = "black", margin = margin(r = 6)),
    axis.text.y  = element_text(size = 22, color = "black"),
    axis.line    = element_line(linewidth = 0.7, color = "black"),
    axis.ticks   = element_line(linewidth = 0.7, color = "black"),
    axis.ticks.length = unit(3.5, "pt"),
    axis.ticks.x = element_blank(),
    axis.title.x = element_blank(),
    axis.text.x = element_text(face = "bold", size = 18, color = "black"),
    strip.text = element_blank(),
    strip.background = element_blank(),
    panel.grid.major.y = element_line(color = "grey85", linewidth = 0.35),
    panel.grid.minor = element_blank(),
    plot.margin = margin(6, 8, 6, 6)
  )

p_pub

# slimmer table (this is what makes patchwork alignment actually visible)

table_df <- gp_GO$result %>%
  arrange(p_value) %>%
  slice_head(n = 10) %>%
  mutate(Rank = row_number()) %>%
  transmute(
    Rank,
    Source = source,
    `Term ID`   = term_id,
    `Term name` = stringr::str_wrap(term_name, width = 45),
    `P (adj)`      = formatC(p_value, format = "e", digits = 2)
  )


tab_grob <- gridExtra::tableGrob(
  table_df,
  rows = NULL,
  theme = gridExtra::ttheme_minimal(
    base_size = 15,
    padding = unit(c(4, 4), "mm"),
    colhead = list(
      fg_params = list(fontface = "bold", col = "black"),
      bg_params = list(fill = "grey95", col = NA)
    ),
    core = list(
      fg_params = list(col = "black", hjust = 0, x = 0.02),
      bg_params = list(fill = c("grey95", "grey93"), col = NA)
    )
  )
)


g <- ggplotGrob(p_pub)

# find panel(s) robustly (works for "panel-1-1", facets, etc.)
panel_rows <- which(grepl("^panel", g$layout$name))
if (length(panel_rows) == 0) stop("Could not find a panel grob in p_pub")

# for facetted plots, take the leftmost panel column
left_panel_col <- min(g$layout$l[panel_rows])

# exact left gutter width up to the left edge of the panel
left_offset <- if (left_panel_col > 1) sum(g$widths[seq_len(left_panel_col - 1)]) else unit(0, "pt")

tab_grob_aligned <- gtable::gtable_add_cols(tab_grob, left_offset, pos = 0)

tab_pw <- patchwork::wrap_elements(full = tab_grob_aligned) +
  theme(plot.margin = margin(0, 7, 0, 0))
# ----------------------------------------------------------------------

final_GO_fig <- p_pub /
  plot_spacer() /
  tab_pw +
  plot_layout(heights = c(2.7, 0, 1.85))

final_GO_fig <- p_pub /
  tab_pw +
  plot_layout(heights = c(2.7, 1.85))

final_GO_fig


ggsave("GO_enrichment_with_table.png", final_GO_fig,
       width = 9.25, height = 10.5, units = "in", dpi = 600)








## Pathway analysis


gp_pathway <- gost(
  query = sig_genes,
  organism = "hsapiens",
  correction_method = "g_SCS",
  user_threshold = 0.01,
  sources = c("KEGG", "REAC", "WP"),
  custom_bg = bg_genes,
  evcodes = TRUE,
)

head(gp_pathway$result)
readr::write_csv(gp_pathway$result, "gprofiler_pathways.csv")

gostplot(gp_pathway, capped = FALSE, interactive = TRUE)


Path <- gostplot(gp_pathway, capped = FALSE, interactive = FALSE)

top_table <- gp_pathway$result %>%
  arrange(p_value) %>%
  slice_head(n = 10) %>%
  mutate(Rank = row_number()) %>%
  dplyr::select(Rank, source, term_id, term_name, p_value) %>%
  transmute(
    Rank,
    Source = source,
    `Term ID` = term_id,
    `Term name` = str_trunc(term_name, 70),
    `P (adj)` = formatC(p_value, format = "e", digits = 2)
  )

top_terms <- top_table$`Term ID`

# first point layer index
pt_idx <- which(vapply(GO$layers, function(l) inherits(l$geom, "GeomPoint"), logical(1)))[1]

# mapping for that layer
m <- GO$layers[[pt_idx]]$mapping

# keep original colors as fill (if color was mapped)
if (is.null(m$fill)) {
  if (!is.null(m$colour)) m$fill <- m$colour
  if (!is.null(m$color))  m$fill <- m$color
}

# remove colour mapping -> black outline
m$colour <- NULL
m$color  <- NULL

# remove size mapping -> constant size
m$size <- NULL

Path$layers[[pt_idx]]$mapping <- m

# outlined points with constant size
Path$layers[[pt_idx]]$aes_params$shape  <- 21
Path$layers[[pt_idx]]$aes_params$colour <- "black"
Path$layers[[pt_idx]]$aes_params$stroke <- 0.5
Path$layers[[pt_idx]]$aes_params$size   <- 5.5   # <- pick your constant point size

# palette for GO sources
my_pal <- c("KEGG" = "#dd4477", "REAC" = "#3366cc", "WP" = "#0099c6")
Path <- Path + scale_fill_manual(values = my_pal) + guides(size = "none")
# Base alpha for everything
base_alpha <- 0.5

# Add a rank column to GO$data for top 10
Path$data <- Path$data %>%
  left_join(
    gp_pathway$result %>%
      arrange(p_value) %>%
      slice_head(n = 10) %>%
      mutate(Rank = row_number()) %>%
      dplyr::select(term_id, Rank),
    by = "term_id"
  ) %>%
  mutate(alpha_pt = ifelse(!is.na(Rank), 1, base_alpha))

# Map alpha per point (and turn off alpha legend)
Path <- Path +
  aes(alpha = alpha_pt) +
  scale_alpha_identity(guide = "none")

# Add rank labels for the top 10
label_df <- Path$data %>% filter(!is.na(Rank))

# remove the fixed alpha so mapping can work
Path$layers[[pt_idx]]$aes_params$alpha <- NULL

# map alpha to alpha_pt on the point layer
Path$layers[[pt_idx]]$mapping$alpha <- rlang::sym("alpha_pt")

# use the alpha values as-is (no legend)
Path <- Path + scale_alpha_identity(guide = "none")

label_df <- Path$data %>% dplyr::filter(!is.na(Rank))

p_pub <- Path +
  ggrepel::geom_label_repel(
    data = label_df,
    aes(x = order, y = logpval, label = Rank),
    inherit.aes = FALSE,
    size = 7.5,
    fontface = "bold",
    color = "black",
    fill = "grey95",               # background fill
    label.size = 0.6,              # border thickness
    label.r = unit(5, "pt"),       # corner roundness
    box.padding = 0.9,
    point.padding = 0.82,
    segment.color = "black",
    segment.size = 0.8,
    min.segment.length = 0,
    max.overlaps = Inf,
    seed = 3
  ) +
  labs(title = "Enriched pathways", y = expression(-log[10](p[adj]))) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.08))) +
  theme_classic(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 33, color = "black", hjust = 0, margin = margin(b = 6)),
    axis.title.y = element_text(face = "bold", size = 22, color = "black", margin = margin(r = 6)),
    axis.text.y  = element_text(size = 22, color = "black"),
    axis.line    = element_line(linewidth = 0.7, color = "black"),
    axis.ticks   = element_line(linewidth = 0.7, color = "black"),
    axis.ticks.length = unit(3.5, "pt"),
    axis.ticks.x = element_blank(),
    axis.title.x = element_blank(),
    axis.text.x = element_text(face = "bold", size = 18, color = "black"),
    strip.text = element_blank(),
    strip.background = element_blank(),
    panel.grid.major.y = element_line(color = "grey85", linewidth = 0.35),
    panel.grid.minor = element_blank(),
    plot.margin = margin(6, 8, 6, 6)
  )

p_pub

# slimmer table (this is what makes patchwork alignment actually visible)

table_df <- gp_pathway$result %>%
  arrange(p_value) %>%
  slice_head(n = 10) %>%
  mutate(Rank = row_number()) %>%
  transmute(
    Rank,
    Source = source,
    `Term ID`   = term_id,
    `Term name` = stringr::str_wrap(term_name, width = 45),
    `P (adj)`      = formatC(p_value, format = "e", digits = 2)
  )


tab_grob <- gridExtra::tableGrob(
  table_df,
  rows = NULL,
  theme = gridExtra::ttheme_minimal(
    base_size = 15,
    padding = unit(c(4, 4), "mm"),
    colhead = list(
      fg_params = list(fontface = "bold", col = "black"),
      bg_params = list(fill = "grey95", col = NA)
    ),
    core = list(
      fg_params = list(col = "black", hjust = 0, x = 0.02),
      bg_params = list(fill = c("grey95", "grey93"), col = NA)
    )
  )
)


g <- ggplotGrob(p_pub)

# find panel(s) robustly (works for "panel-1-1", facets, etc.)
panel_rows <- which(grepl("^panel", g$layout$name))
if (length(panel_rows) == 0) stop("Could not find a panel grob in p_pub")

# for facetted plots, take the leftmost panel column
left_panel_col <- min(g$layout$l[panel_rows])

# exact left gutter width up to the left edge of the panel
left_offset <- if (left_panel_col > 1) sum(g$widths[seq_len(left_panel_col - 1)]) else unit(0, "pt")

tab_grob_aligned <- gtable::gtable_add_cols(tab_grob, left_offset, pos = 0)

tab_pw <- patchwork::wrap_elements(full = tab_grob_aligned) +
  theme(plot.margin = margin(0, 7, 0, 0))
# ----------------------------------------------------------------------


final_Path_fig <- p_pub /
  tab_pw +
  plot_layout(heights = c(2.7, 1.85))

final_Path_fig

ggsave("Pathway_Enrichments_with_table.png", final_Path_fig,
       width = 10, height = 10.5, units = "in", dpi = 600)


# Selected pathway genes

# sanity check: see what the overlap column is called
names(gp_pathway$result)

# pick the overlap column name robustly
overlap_col <- intersect(c("intersection", "intersections"), names(gp_pathway$result))[1]
stopifnot(!is.na(overlap_col))

genes_pathway <- gp_pathway$result %>%
  filter(term_id == "REAC:R-HSA-909733") %>%
  slice(1) %>%                              # just in case duplicates
  pull(!!sym(overlap_col)) %>%
  str_split(",") %>%
  .[[1]] %>%
  str_trim() %>%
  .[. != ""] %>%
  unique()

length(genes_pathway)
head(genes_pathway, 30)


deseq_long <- deseq_tbl %>%
  transmute(
    symbol = SYMBOL_clean,
    log2FoldChange,
    padj
  ) %>%
  separate_rows(symbol, sep = ";") %>%
  mutate(symbol = str_trim(symbol)) %>%
  filter(!is.na(symbol), symbol != "") %>%
  distinct(symbol, .keep_all = TRUE)

pathway_gene_stats <- deseq_long %>%
  filter(symbol %in% genes_pathway) %>%
  arrange(padj)

pathway_gene_stats

readr::write_csv(pathway_gene_stats, "REAC_R-HSA-909733_genes_DESeq2.csv")
